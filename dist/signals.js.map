{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "index.js",
    "lib/signal.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "exports.signal = require('./lib/signal');",
    "/**\r\n * Creates a new signal.\r\n *\r\n * @param name The optional name of the signal displayed in error messages.\r\n */\r\nfunction signal(name) {\r\n    var handlers = [], connections = [],\r\n        isEmitting = false, isPendingDisconnectAll = false;\r\n\r\n    name = String(name || '') || 'Unknown';\r\n\r\n    // s(handler, priority)\r\n    // s(handler, thisObj)\r\n    // s(handler, thisObj, priority)\r\n    function s(handler, thisObj, priority) {\r\n        if (!isNaN(thisObj)) {\r\n            priority = thisObj;\r\n            thisObj = undefined;\r\n        }\r\n\r\n        if (isNaN(priority)) {\r\n            priority = 1000;\r\n        }\r\n\r\n        var proxyHandler = function () {\r\n            var args = [].slice.call(arguments);\r\n            return handler.apply(thisObj, args);\r\n        };\r\n        proxyHandler.priority = priority;\r\n\r\n        handlers.push(proxyHandler);\r\n        handlers.sort(prioritize);\r\n\r\n        var connection = {\r\n            disconnect: function () {\r\n                if (handler) {\r\n                    handler = null;\r\n                    var k = handlers.indexOf(proxyHandler);\r\n                    handlers.splice(k, 1);\r\n                    proxyHandler = null;\r\n                }\r\n            }\r\n        };\r\n\r\n        connections.push(connection);\r\n\r\n        return connection;\r\n    }\r\n\r\n    // emit(...args)\r\n    s.emit = function () {\r\n        var args, cancelled;\r\n\r\n        isEmitting = true;\r\n        args = [].slice.call(arguments);\r\n\r\n        for (var k = handlers.length - 1; k >= 0 && !cancelled; k -= 1) {\r\n            cancelled = signal.CANCEL === handlers[k].apply(undefined, args);\r\n        }\r\n\r\n        isEmitting = false;\r\n\r\n        if (isPendingDisconnectAll) {\r\n            isPendingDisconnectAll = false;\r\n            this.disconnectAll();\r\n        }\r\n\r\n        return !cancelled;\r\n    };\r\n\r\n    s.unlock = function () {\r\n        return s;\r\n    };\r\n\r\n    s.lock = function (key) {\r\n        if (!key) {\r\n            throw new Error(\"[\" + name + \"] Cannot lock a signal with a falsy key.\");\r\n        }\r\n\r\n        function ss() {\r\n            return s.apply(void 0, [].slice.call(arguments));\r\n        }\r\n\r\n        ss.emit = function () {\r\n            throw new Error(\"[\" + name + \"] Cannot emit a locked signal.\");\r\n        };\r\n        ss.unlock = function (aKey) {\r\n            if (aKey === key) {\r\n                return s;\r\n            }\r\n\r\n            throw new Error(\"[\" + name + \"] Failed to unlock locked signal.\");\r\n        };\r\n        ss.lock = function () {\r\n            throw new Error(\"[\" + name + \"] Cannot lock a locked signal.\");\r\n        };\r\n\r\n        return ss;\r\n    };\r\n\r\n    s.disconnectAll = function () {\r\n        if (isEmitting || isPendingDisconnectAll) {\r\n            isPendingDisconnectAll = true;\r\n        } else {\r\n            while (connections.length) {\r\n                connections.pop().disconnect();\r\n            }\r\n        }\r\n\r\n        return s;\r\n    };\r\n\r\n    return s;\r\n}\r\n\r\nfunction prioritize(a, b) {\r\n    return a.priority - b.priority;\r\n}\r\n\r\n/**\r\n * If returned from a handler connected to a signal it will cancel the signal\r\n * and no other connected handlers will be invoked.\r\n */\r\nsignal.CANCEL = {};\r\n\r\nmodule.exports = signal;"
  ]
}